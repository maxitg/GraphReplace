Package["SetReplace`"]

PackageImport["GeneralUtilities`"]

PackageExport["WolframModelEvolutionObject"]

(* This is an object that is returned by WolframModel. It allows one to query the set at different generations and
   different steps. *)

PackageScope["propertyEvaluate"]
PackageScope["evolutionDataQ"]

PackageScope["$propertiesParameterless"]
PackageScope["$newParameterlessProperties"]

(* Keys in the data association. *)
PackageScope["$version"]
PackageScope["$rules"]
PackageScope["$maxCompleteGeneration"]
PackageScope["$terminationReason"]
PackageScope["$atomLists"]
PackageScope["$eventRuleIDs"]
PackageScope["$eventInputs"]
PackageScope["$eventOutputs"]
PackageScope["$eventGenerations"]
PackageScope["$creatorEvents"]
PackageScope["$destroyerEvents"]
PackageScope["$generations"]

$version = "Version";
$rules = "Rules";
$maxCompleteGeneration = "MaxCompleteGeneration";
$terminationReason = "TerminationReason";
$atomLists = "AtomLists";
$eventRuleIDs = "EventRuleIDs";
$eventInputs = "EventInputs";
$eventOutputs = "EventOutputs";
$eventGenerations = "EventGenerations";

(* Old keys *)
$creatorEvents = "CreatorEvents";
$destroyerEvents = "DestroyerEvents";
$generations = "Generations";

SetUsage @ "
WolframModelEvolutionObject[$$] is an evolution object generated by WolframModel.
WolframModelEvolutionObject[$$][g$] yields the set at generation g$.
WolframModelEvolutionObject[$$]['StateAfterEvent', s$] yields the state after s$ substitution events.
WolframModelEvolutionObject[$$]['Properties'] yields the list of all available properties.
"

SyntaxInformation[WolframModelEvolutionObject] = {"ArgumentsPattern" -> {___}};

(* MakeBoxes *)

WolframModelEvolutionObject /:
    MakeBoxes[
      evo : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      format_] := ModuleScope[
  generationsCount = evo["TotalGenerationsCount"];
  maxCompleteGeneration = Replace[evo["CompleteGenerationsCount"], _ ? MissingQ -> "?"];
  generationsDisplay = If[generationsCount === maxCompleteGeneration,
    generationsCount,
    Row[{maxCompleteGeneration, "\[Ellipsis]", generationsCount}]];
  eventsCount = evo["AllEventsCount"];
  terminationReason = evo["TerminationReason"];
  rules = evo["Rules"];
  initialSet = evo[0];
  BoxForm`ArrangeSummaryBox[
    WolframModelEvolutionObject,
    evo,
    style[$lightTheme][$evolutionObjectIcon],
    (* Always grid *)
    {{BoxForm`SummaryItem[{"Generations: ", generationsDisplay}]},
    {BoxForm`SummaryItem[{"Events: ", eventsCount}]}},
    (* Sometimes grid *)
    {If[MissingQ[terminationReason], Nothing, {BoxForm`SummaryItem[{"Termination reason: ", terminationReason}]}],
    {BoxForm`SummaryItem[{"Rules: ", Short[rules]}]},
    {BoxForm`SummaryItem[{"Initial set: ", Short[initialSet]}]}},
    format,
    "Interpretable" -> Automatic
  ]
]

$accessorProperties = <|
  "Version" -> $version,
  "Rules" -> $rules,
  "CompleteGenerationsCount" -> $maxCompleteGeneration,
  "AllEventsEdgesList" -> $atomLists
|>;

$propertyArgumentCounts = Join[
  <|
    "EvolutionObject" -> {0, 0},
    "FinalState" -> {0, 0},
    "FinalStatePlot" -> {0, Infinity},
    "StatesList" -> {0, 0},
    "StatesPlotsList" -> {0, Infinity},
    "EventsStatesPlotsList" -> {0, Infinity},
    "AllEventsStatesEdgeIndicesList" -> {0, 0},
    "AllEventsStatesList" -> {0, 0},
    "GenerationEdgeIndices" -> {1, 1},
    "Generation" -> {1, 1},
    "StateEdgeIndicesAfterEvent" -> {1, 1},
    "StateAfterEvent" -> {1, 1},
    "TotalGenerationsCount" -> {0, 0},
    "PartialGenerationsCount" -> {0, 0},
    "GenerationsCount" -> {0, 0},
    "GenerationComplete" -> {0, 1},
    "AllEventsCount" -> {0, 0},
    "GenerationEventsCountList" -> {0, 0},
    "GenerationEventsList" -> {0, 0},
    "FinalDistinctElementsCount" -> {0, 0},
    "AllEventsDistinctElementsCount" -> {0, 0},
    "VertexCountList" -> {0, 0},
    "EdgeCountList" -> {0, 0},
    "FinalEdgeCount" -> {0, 0},
    "AllEventsEdgesCount" -> {0, 0},
    "AllEventsGenerationsList" -> {0, 0},
    "ExpressionsEventsGraph" -> {0, Infinity},
    "CausalGraph" -> {0, Infinity},
    "LayeredCausalGraph" -> {0, Infinity},
    "TerminationReason" -> {0, 0},
    "AllEventsRuleIndices" -> {0, 0},
    "AllEventsList" -> {0, 0},
    "EventsStatesList" -> {0, 0},
    "EdgeCreatorEventIndices" -> {0, 0},
    "EdgeDestroyerEventsIndices" -> {0, 0},
    "EdgeDestroyerEventIndices" -> {0, 0},
    "EdgeGenerationsList" -> {0, 0},
    "FeatureVector" -> {0, 0},
    "ExpressionsSeparation" -> {2, 2},
    "MultiwayQ" -> {0, 0},
    "Properties" -> {0, 0}|>,
  Association[# -> {0, 0} & /@ Keys[$accessorProperties]]];

(* These are here for compatibility with old code. *)
$oldToNewPropertyNames = <|
  "UpdatedStatesList" -> "AllEventsStatesList",
  "AllExpressions" -> "AllEventsEdgesList",
  "CreatorEvents" -> "EdgeCreatorEventIndices",
  "DestroyerEvents" -> "EdgeDestroyerEventIndices",
  "MaxCompleteGeneration" -> "CompleteGenerationsCount",
  "EventGenerations" -> "AllEventsGenerationsList",
  "EventGenerationsList" -> "AllEventsGenerationsList",
  "ExpressionGenerations" -> "EdgeGenerationsList",
  "EventsCount" -> "AllEventsCount",
  "EventsList" -> "AllEventsList",
  "AtomsCountFinal" -> "FinalDistinctElementsCount",
  "AtomsCountTotal" -> "AllEventsDistinctElementsCount",
  "ExpressionsCountFinal" -> "FinalEdgeCount",
  "ExpressionsCountTotal" -> "AllEventsEdgesCount",
  "SetAfterEvent" -> "StateAfterEvent"
|>;

$propertiesParameterless = Join[
  Keys @ Select[#[[1]] == 0 &] @ $propertyArgumentCounts,
  Select[First[$propertyArgumentCounts[$oldToNewPropertyNames[#]]] == 0 &] @ Keys[$oldToNewPropertyNames]
];

$newParameterlessProperties = Intersection[$propertiesParameterless, Keys[$propertyArgumentCounts]];

(* Master options handling *)

General::missingMaxCompleteGeneration = "Cannot drop incomplete generations in an object with missing information.";

propertyEvaluate[False, boundary_][evolution_, caller_, rest___] := If[MissingQ[evolution["CompleteGenerationsCount"]],
  Message[caller::missingMaxCompleteGeneration],
  propertyEvaluate[True, boundary][deleteIncompleteGenerations[evolution], caller, rest]
]

propertyEvaluate[False, boundary_][evolution_, caller_, rest___] :=
  propertyEvaluate[True, boundary][deleteIncompleteGenerations[evolution], caller, rest]

propertyEvaluate[includePartialGenerations : Except[True | False], _][evolution_, caller_, ___] := (
  Message[caller::invalidFiniteOption, "IncludePartialGenerations", includePartialGenerations, {True, False}];
  Throw[$Failed]
)

includeBoundaryEventsPattern = None | "Initial" | "Final" | All;

propertyEvaluate[_, boundary : Except[includeBoundaryEventsPattern]][evolution_, caller_, ___] := (
  Message[caller::invalidFiniteOption, "IncludeBoundaryEvents", boundary, {None, "Initial", "Final", All}];
  Throw[$Failed]
)

deleteIncompleteGenerations[WolframModelEvolutionObject[data_]] := ModuleScope[
  maxCompleteGeneration = data[$maxCompleteGeneration];
  eventIndicesToKeep = Position[data[$eventGenerations], _ ? (# <= maxCompleteGeneration &)][[All, 1]];
  newEventOutputs = data[$eventOutputs][[eventIndicesToKeep]];
  expressionIndicesToKeep = Union[Catenate[newEventOutputs]];
  oldToNewExpressionIndices = Dispatch @ Thread[expressionIndicesToKeep -> Range[Length[expressionIndicesToKeep]]];
  WolframModelEvolutionObject[<|$version -> data[$version],
    $rules -> data[$rules],
    $maxCompleteGeneration -> data[$maxCompleteGeneration],
    $terminationReason -> data[$terminationReason],
    $atomLists -> data[$atomLists][[expressionIndicesToKeep]],
    $eventRuleIDs -> data[$eventRuleIDs][[eventIndicesToKeep]],
    $eventInputs -> Replace[data[$eventInputs][[eventIndicesToKeep]], oldToNewExpressionIndices, {2}],
    $eventOutputs -> Replace[newEventOutputs, oldToNewExpressionIndices, {2}],
    $eventGenerations -> data[$eventGenerations][[eventIndicesToKeep]]|>]
]

(* Unknown property *)

propertyEvaluate[masterOptions___][
    obj_WolframModelEvolutionObject, caller_, property : Alternatives @@ Keys[$oldToNewPropertyNames], args___] :=
  propertyEvaluate[masterOptions][obj, caller, $oldToNewPropertyNames[property], args]

propertyEvaluate[___][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    s : Except[_Integer],
    ___] /; !MemberQ[Keys[$propertyArgumentCounts], s] := (
  makeMessage[caller, "unknownProperty", s];
  Throw[$Failed]
)

(* Check property argument counts *)

makePargxMessage[property_, caller_, givenArgs_, expectedArgs_] := makeMessage[
  caller,
  "pargx",
  property,
  givenArgs,
  If[givenArgs == 1, "", "s"],
  If[expectedArgs[[1]] != expectedArgs[[2]], "between ", ""],
  expectedArgs[[1]],
  If[expectedArgs[[1]] != expectedArgs[[2]], " and ", ""],
  If[expectedArgs[[1]] != expectedArgs[[2]], expectedArgs[[2]], ""],
  If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "s", ""],
  If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "are", "is"]
]

propertyEvaluate[___][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    s_String,
    args___] /;
      With[{argumentsCountRange = $propertyArgumentCounts[s]},
        Not[MissingQ[argumentsCountRange]] &&
        Not[argumentsCountRange[[1]] <= Length[{args}] <= argumentsCountRange[[2]]]] := (
  makePargxMessage[s, caller, Length[{args}], $propertyArgumentCounts[s]];
  Throw[$Failed]
)

WolframModelEvolutionObject::invalidNargs = "`1` is called with `2` arguments. " <>
  "Either 1 argument is expected for implicit \"Generation\", or a property " <>
  "name is expected as the first argument.";

propertyEvaluate[___][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    g_Integer,
    args__] := (
  Message[
    WolframModelEvolutionObject::invalidNargs,
    HoldForm[WolframModelEvolutionObject[data][g, args]],
    Length @ {g, args}];
  Throw[$Failed]
)

(* Check options *)

$newCausalGraphOptions = {Background -> Automatic, VertexStyle -> Automatic, EdgeStyle -> Automatic};
$causalGraphOptions = Join[FilterRules[Options[Graph], Except[$newCausalGraphOptions]], $newCausalGraphOptions];

$newLayeredCausalGraphOptions = {GraphLayout -> Automatic};
$layeredCausalGraphOptions =
  Join[FilterRules[$causalGraphOptions, Except[$newLayeredCausalGraphOptions]], $newLayeredCausalGraphOptions];

$newExpressionsEventsGraphOptions = {VertexLabels -> None};
$expressionsEventsGraphOptions = Join[
  FilterRules[$layeredCausalGraphOptions, Except[$newExpressionsEventsGraphOptions]],
  $newExpressionsEventsGraphOptions];

$propertyOptions = <|
  "ExpressionsEventsGraph" -> $expressionsEventsGraphOptions,
  "CausalGraph" -> $causalGraphOptions,
  "LayeredCausalGraph" -> $layeredCausalGraphOptions,
  "StatesPlotsList" -> Options[HypergraphPlot],
  "EventsStatesPlotsList" -> Options[HypergraphPlot],
  "FinalStatePlot" -> Options[HypergraphPlot]
|>;

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    property : Alternatives @@ Keys[$propertyOptions],
    o : OptionsPattern[]] := (
  Message[
    caller::optx,
    First[Last[Complement[{o}, FilterRules[{o}, Options[$propertyOptions[property]]]]]],
    Defer[obj[property, o]]];
  Throw[$Failed]
)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    property : Alternatives @@ Keys[$propertyOptions],
    o___] := (
  makeMessage[caller, "nonopt", property, Last[{o}]];
  Throw[$Failed]
)

(* Convert to positive parameter (i.e., generation) number, similar to, e.g., expr[[-1]] *)

toPositiveParameter[min_ : 0, total_, requested_, caller_, name_] := Switch[requested,
  Except[_Integer],
    makeMessage[caller, "parameterNotInteger", name, requested];
    Throw[$Failed],
  _ ? (# > total || # < - total - 1 + min &),
    makeMessage[caller, "parameterTooLarge", name, requested, total];
    Throw[$Failed],
  _ ? (0 <= # < min &),
    makeMessage[caller, "parameterTooSmall", name, requested, min];
    Throw[$Failed],
  _ ? Negative,
    1 + total + requested,
  _,
    requested
]

(** Properties **)

propertyEvaluate[___][
    WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "Properties"] :=
  Keys[$propertyArgumentCounts]

(* EvolutionObject *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "EvolutionObject"] := WolframModelEvolutionObject[data]

(* Rules *)

propertyEvaluate[___][
    WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "Rules"] :=
  data[$rules]

(* TotalGenerationsCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "TotalGenerationsCount"] := Max[data[$eventGenerations]]

(* PartialGenerationsCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "PartialGenerationsCount"] :=
  If[MissingQ[obj["CompleteGenerationsCount"]],
    obj["CompleteGenerationsCount"],
    obj["TotalGenerationsCount"] - obj["CompleteGenerationsCount"]]

(* GenerationsCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "GenerationsCount"] := obj /@ {"CompleteGenerationsCount", "PartialGenerationsCount"}

(* GenerationComplete *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "GenerationComplete",
    generation_Integer] /; generation >= 0 := generation <= obj["CompleteGenerationsCount"]

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "GenerationComplete",
    generation_ : -1] :=
  toPositiveParameter[
      propertyEvaluate[True, None][obj, caller, "TotalGenerationsCount"], generation, caller, "Generation"] <=
    obj["CompleteGenerationsCount"]

(* AllEventsCount *)

propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "AllEventsCount"] :=
  Length[data[$eventRuleIDs]] + Switch[includeBoundaryEvents, None, -1, "Initial" | "Final", 0, All, 1]

(* GenerationEventsCountList *)

propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ], caller_, "GenerationEventsCountList"] :=
  Length /@ Split[propertyEvaluate[True, includeBoundaryEvents][obj, caller, "AllEventsGenerationsList"]]

(* GenerationEventsList *)

propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ], caller_, "GenerationEventsList"] :=
  TakeList[
    propertyEvaluate[True, includeBoundaryEvents][obj, caller, "AllEventsList"],
    propertyEvaluate[True, includeBoundaryEvents][obj, caller, "GenerationEventsCountList"]]

(* Direct Accessors of object properties *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    property_ ? (MemberQ[Keys[$accessorProperties], #] &)] :=
  Lookup[data, $accessorProperties[property], Missing["NotAvailable"]];

(* StateEdgeIndicesAfterEvents (not a property yet) *)

stateEdgeIndicesAfterEvents[WolframModelEvolutionObject[data_], caller_, events_] := ModuleScope[
  createdExpressions = Catenate[data[$eventOutputs][[events + 1]]];
  destroyedExpressions = Catenate[data[$eventInputs][[events + 1]]];
  If[DuplicateFreeQ[destroyedExpressions],
    Sort[Complement[createdExpressions, destroyedExpressions]],
  (* else *)
    makeMessage[caller, "multiwayState", Last[Keys[Sort[Counts[destroyedExpressions]]]]];
    Throw[$Failed]
  ]
]

(* StateEdgeIndicesAfterEvent *)

propertyEvaluate[True, includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      "StateEdgeIndicesAfterEvent",
      s_] := With[{
    positiveEvent =
      toPositiveParameter[propertyEvaluate[True, None][obj, caller, "AllEventsCount"], s, caller, "Event"]},
  stateEdgeIndicesAfterEvents[obj, caller, Range[0, positiveEvent]]
]

(* StateAfterEvent *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      "StateAfterEvent",
      s_] := data[$atomLists][[propertyEvaluate[True, boundary][obj, caller, "StateEdgeIndicesAfterEvent", s]]]

(* FinalState *)

propertyEvaluate[True, boundary: includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "FinalState"] := propertyEvaluate[True, boundary][obj, caller, "StateAfterEvent", -1]

(* FinalStatePlot *)

General::nonHypergraphPlot = "`1` is only supported for states that are hypergraphs.";

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    property : "FinalStatePlot",
    o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[HypergraphPlot]]] == {})] :=
  Check[
    Quiet[
      Check[
        HypergraphPlot[propertyEvaluate[True, boundary][obj, caller, "FinalState"], o],
        Message[caller::nonHypergraphPlot, property],
        HypergraphPlot::invalidEdges],
      HypergraphPlot::invalidEdges],
    Throw[$Failed]]

(* AllEventsStatesEdgeIndicesList & AllEventsStatesList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    property : "AllEventsStatesList" | "AllEventsStatesEdgeIndicesList"] :=
  propertyEvaluate[True, boundary][
      evolution,
      caller,
      Replace[
        property,
        {"AllEventsStatesList" -> "StateAfterEvent", "AllEventsStatesEdgeIndicesList" -> "StateEdgeIndicesAfterEvent"}],
      #] & /@
    Range[0, propertyEvaluate[True, None][WolframModelEvolutionObject[data], caller, "AllEventsCount"]]

(* GenerationEdgeIndices *)

propertyEvaluate[True, includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      "GenerationEdgeIndices",
      g_] := ModuleScope[
  positiveGeneration = toPositiveParameter[
    propertyEvaluate[True, None][obj, caller, "TotalGenerationsCount"], g, caller, "Generation"];
  eventsUpToGeneration = First /@ Position[_ ? (# <= positiveGeneration &)] @ data[$eventGenerations] - 1;
  stateEdgeIndicesAfterEvents[obj, caller, eventsUpToGeneration]
]

(* Generation *)

(* Note that depending on how evaluation was done (i.e., the order of substitutions), it is possible that some
   expressions of a requested generation were not yet produced, and thus expressions for the previous generation would
   be used instead. That, however, should never happen if the evolution object is produced with WolframModel. *)

propertyEvaluate[True, includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      "Generation",
      g_] := data[$atomLists][[propertyEvaluate[True, None][obj, caller, "GenerationEdgeIndices", g]]]

(* Implicit generation, e.g., object[2] *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, g_Integer] :=
  propertyEvaluate[True, None][WolframModelEvolutionObject[data], caller, "Generation", g]

(* StatesList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "StatesList"] :=
  propertyEvaluate[True, boundary][obj, caller, "Generation", #] & /@
    Range[0, propertyEvaluate[True, boundary][obj, caller, "TotalGenerationsCount"]]

(* StatesPlotsList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    property : "StatesPlotsList",
    o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[HypergraphPlot]]] == {})] :=
  Check[
    Quiet[
      Map[
        Check[
          Check[
            HypergraphPlot[#, o],
            Message[caller::nonHypergraphPlot, property],
            HypergraphPlot::invalidEdges],
          Throw[$Failed]] &,
        propertyEvaluate[True, boundary][obj, caller, "StatesList"]],
      HypergraphPlot::invalidEdges],
    Throw[$Failed]]

(* EventsStatesPlotsList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
      caller_,
      property : "EventsStatesPlotsList",
      o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[HypergraphPlot]]] == {})] := ModuleScope[
  events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"][[All, 2]];
  stateIndices = FoldList[
    Function[{currentState, newEvent}, Module[{alreadyDeletedExpressions},
      alreadyDeletedExpressions = Complement[newEvent[[1]], currentState];
      If[alreadyDeletedExpressions =!= {},
        makeMessage[caller, "multiwayState", alreadyDeletedExpressions[[1]]];
        Throw[$Failed]];
      Join[DeleteCases[currentState, Alternatives @@ newEvent[[1]]], newEvent[[2]]]]],
    If[MatchQ[boundary, "Initial" | All],
      {},
      propertyEvaluate[True, None][obj, caller, "StateEdgeIndicesAfterEvent", 0]
    ],
    events];
  {destroyedOnlyIndices, createdOnlyIndices, destroyedAndCreatedIndices} = Transpose[MapThread[
    {Complement[##], Complement[#2, #1], Intersection[##]} &,
    {Append[events[[All, 1]], {}], Prepend[events[[All, 2]], {}]}]];
  allEdges = propertyEvaluate[True, None][obj, caller, "AllEventsEdgesList"];
  Check[
    Quiet[
      MapThread[
        Check[
          Check[
            HypergraphPlot[
              allEdges[[#]],
              o,
              EdgeStyle -> ReplacePart[
                Table[Automatic, Length[#]],
                Join[
                  Thread[Position[#, Alternatives @@ #2][[All, 1]] -> style[$lightTheme][$destroyedEdgeStyle]],
                  Thread[Position[#, Alternatives @@ #3][[All, 1]] -> style[$lightTheme][$createdEdgeStyle]],
                  Thread[Position[#, Alternatives @@ #4][[All, 1]] ->
                    style[$lightTheme][$destroyedAndCreatedEdgeStyle]]]]],
            Message[caller::nonHypergraphPlot, property],
            HypergraphPlot::invalidEdges],
          Throw[$Failed]] &,
        If[MatchQ[boundary, "Initial" | All], Rest /@ # &, # &] @
          If[MatchQ[boundary, All | "Final"], Most /@ # &, # &] @
          {stateIndices, destroyedOnlyIndices, createdOnlyIndices, destroyedAndCreatedIndices}],
      HypergraphPlot::invalidEdges],
    Throw[$Failed]]
]

(* FinalDistinctElementsCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "FinalDistinctElementsCount"] :=
  Length[Union @ Cases[
    propertyEvaluate[True, None][
      WolframModelEvolutionObject[data], caller, "StateAfterEvent", -1],
    _ ? AtomQ,
    All]]

(* AllEventsDistinctElementsCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "AllEventsDistinctElementsCount"] :=
  Length[Union @ Cases[data[$atomLists], _ ? AtomQ, All]]

(* VertexCountList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "VertexCountList"] :=
  Length /@ Union /@ Catenate /@ propertyEvaluate[True, boundary][obj, caller, "StatesList"]

(* EdgeCountList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "EdgeCountList"] :=
  Length /@ propertyEvaluate[True, boundary][obj, caller, "StatesList"]

(* FinalEdgeCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "FinalEdgeCount"] :=
  Length[propertyEvaluate[True, None][
    WolframModelEvolutionObject[data], caller, "StateAfterEvent", -1]]

(* AllEventsEdgesCount *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "AllEventsEdgesCount"] :=
  Length[data[$atomLists]]

(* AllEventsGenerationsList *)

propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
    evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "AllEventsGenerationsList"] :=
  If[MatchQ[includeBoundaryEvents, All | "Final"], Append[evolution["TotalGenerationsCount"] + 1], Identity] @
    If[MatchQ[includeBoundaryEvents, None | "Final"], Rest, Identity] @
      data[$eventGenerations]

(* Event/expression causal relations, used by both expressions-events and causal graphs *)
(* Returns {<|event -> {output expression, ...}, ...|>, <|expression -> {destroyer event, ...}|> *)

eventsExpressionsRelations[obj_, caller_, boundary_] := ModuleScope[
  eventIndices = If[MatchQ[boundary, "Initial" | All], Prepend[0], Identity] @
    If[MatchQ[boundary, All | "Final"], Append[Infinity], Identity] @
      Range[Length[obj[[1]][$eventRuleIDs]] - 1];
  events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"];
  eventsToOutputs = Association[Thread[eventIndices -> events[[All, 2, 2]]]];

  expressionDestroyers = propertyEvaluate[True, boundary][obj, caller, "EdgeDestroyerEventsIndices"];
  expressionsToDestroyers = Association[Thread[Range[Length[expressionDestroyers]] -> expressionDestroyers]];

  {eventsToOutputs, expressionsToDestroyers}
]

(* ExpressionsEventsGraph *)

rulesList[rule_Association] := rulesList[rule["PatternRules"]]
rulesList[rule : (_Rule | _RuleDelayed)] := {rule}
rulesList[rules_List] := rules

(* ImageSize -> Automatic (which is the default) causes the size of the output to be reset on reevaluation *)
filterGraphProperties[properties_] := FilterRules[properties, Except[ImageSize]]

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      property : "ExpressionsEventsGraph",
      o : OptionsPattern[]] /;
        (Complement[{o}, FilterRules[{o}, $propertyOptions[property]]] == {}) := ModuleScope[
  {eventsToOutputs, expressionsToDestroyers} = eventsExpressionsRelations[obj, caller, boundary];
  {labeledEvents, labeledOutputs, labeledExpressions, labeledDestroyers} =
    Function[{list, label, level}, Map[{label, #} &, list, level]] @@@ {
      {Keys[eventsToOutputs], "Event", {1}},
      {Values[eventsToOutputs], "Expression", {2}},
      {Keys[expressionsToDestroyers], "Expression", {1}},
      {Values[expressionsToDestroyers], "Event", {2}}};
  graphVertices = Join[labeledEvents, labeledExpressions];

  allOptionValues = Flatten[Join[{o}, filterGraphProperties[$propertyOptions[property]]]];

  vertexLabelsOptionValue = OptionValue[allOptionValues, VertexLabels];
  automaticVertexLabelsPattern = Automatic | Placed[Automatic, ___];
  If[MatchQ[vertexLabelsOptionValue, automaticVertexLabelsPattern],
    rules = rulesList[propertyEvaluate[True, None][obj, caller, "Rules"]];
    eventRuleIDs = propertyEvaluate[True, None][obj, caller, "AllEventsRuleIndices"];
    allExpressions = propertyEvaluate[True, None][obj, caller, "AllExpressions"];
    placementFunction = Replace[vertexLabelsOptionValue, {
      Automatic -> Identity,
      Placed[Automatic, args___] :> (Placed[#, args] &)
    }];
  ];

  Graph[
    graphVertices,
    Catenate[Function[{key, values}, key -> # & /@ values] @@@
      Catenate[Transpose /@ {{labeledEvents, labeledOutputs}, {labeledExpressions, labeledDestroyers}}]],
    VertexStyle -> Replace[
      OptionValue[allOptionValues, VertexStyle],
      Automatic :> Join[
        {{"Event", _} -> style[$lightTheme][$causalGraphVertexStyle],
         {"Expression", _} -> style[$lightTheme][$expressionVertexStyle]},
        Cases[
          graphVertices,
          v : {"Event", e : 0 | Infinity} :> v -> style[$lightTheme][Switch[e,
            0, $causalGraphInitialVertexStyle,
            Infinity, $causalGraphFinalVertexStyle]],
          {1}]]],
    EdgeStyle -> Replace[
      OptionValue[allOptionValues, EdgeStyle], Automatic :> style[$lightTheme][$causalGraphEdgeStyle]],
    VertexLabels -> Replace[
      OptionValue[allOptionValues, VertexLabels], {
        automaticVertexLabelsPattern :> Replace[graphVertices, {
          v : {"Event", 0} :> v -> placementFunction["Initial event"],
          v : {"Event", Infinity} :> v -> placementFunction["Final event"],
          v : {"Event", idx_} :> v ->
            If[Length[rules] > 1, placementFunction["Rule " <> ToString[eventRuleIDs[[idx]]]], None],
          v : {"Expression", idx_} :> v -> placementFunction[ToString[allExpressions[[idx]]]]}, {1}],
        "Index" -> Placed["Name", Automatic, Last]}],
    GraphLayout -> Replace[
      OptionValue[allOptionValues, GraphLayout],
      Automatic :> {
        "LayeredDigraphEmbedding",
        "VertexLayerPosition" -> Catenate[{
          2 ("TotalGenerationsCount" - "AllEventsGenerationsList") + 1,
          2 ("TotalGenerationsCount" - "EdgeGenerationsList")} /.
            p_String :> propertyEvaluate[True, boundary][obj, caller, p]]}],
    Background -> Replace[
      OptionValue[allOptionValues, Background], Automatic :> style[$lightTheme][$causalGraphBackground]],
    allOptionValues]
]

(* CausalGraph *)
(* This produces a causal network for the system. This is a Graph with all events as vertices, and directed edges
   connecting them if the same event is a creator and a destroyer for the same expression (i.e., if two events are
   causally related). *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
      caller_,
      property : "CausalGraph",
      o : OptionsPattern[]] /;
        (Complement[{o}, FilterRules[{o}, $propertyOptions[property]]] == {}) := ModuleScope[
  {eventsToOutputs, expressionsToDestroyers} = eventsExpressionsRelations[obj, caller, boundary];
  eventsToEvents = Catenate /@ Map[expressionsToDestroyers, eventsToOutputs, {2}];
  causalEdges = Catenate[Thread /@ Normal[eventsToEvents]];

  allOptionValues = Flatten[Join[{o}, filterGraphProperties[$propertyOptions[property]]]];
  Graph[
    Keys[eventsToOutputs],
    causalEdges,
    VertexStyle -> Replace[
      OptionValue[allOptionValues, VertexStyle],
      Automatic -> Select[Head[#] =!= Rule || MatchQ[#[[1]], Alternatives @@ Keys[eventsToOutputs]] &] @ {
        style[$lightTheme][$causalGraphVertexStyle],
        0 -> style[$lightTheme][$causalGraphInitialVertexStyle],
        Infinity -> style[$lightTheme][$causalGraphFinalVertexStyle]}],
    EdgeStyle -> Replace[
      OptionValue[allOptionValues, EdgeStyle], Automatic -> style[$lightTheme][$causalGraphEdgeStyle]],
    Background -> Replace[
      OptionValue[allOptionValues, Background], Automatic -> style[$lightTheme][$causalGraphBackground]],
    allOptionValues]
]

(* LayeredCausalGraph *)

propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
    evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    property : "LayeredCausalGraph",
    o : OptionsPattern[]] /;
      (Complement[{o}, FilterRules[{o}, $propertyOptions[property]]] == {}) :=
  Graph[
    propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "CausalGraph", ##] & @@
      FilterRules[FilterRules[{o}, $causalGraphOptions], Except[$newLayeredCausalGraphOptions]],
    GraphLayout -> Replace[
      OptionValue[Flatten[Join[{o}, $propertyOptions[property]]], GraphLayout],
      Automatic -> {
        "LayeredDigraphEmbedding",
        "VertexLayerPosition" ->
          (propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "TotalGenerationsCount"] -
              propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "AllEventsGenerationsList"])}]]

(* TerminationReason *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "TerminationReason"] := Replace[data[[Key[$terminationReason]]], Join[Normal[$stepSpecKeys], {
  $fixedPoint -> "FixedPoint",
  $timeConstraint -> "TimeConstraint",
  $Aborted -> "Aborted",
  x : (_ ? MissingQ | Automatic) :> x,
  _ -> Missing["NotAvailable"]
}]]

(* AllEventsRuleIndices *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "AllEventsRuleIndices"] := propertyEvaluate[True, boundary][obj, caller, "AllEventsList"][[All, 1]]

(* AllEventsList *)

finalEvent[WolframModelEvolutionObject[data_]] :=
  {Infinity, Complement[Catenate[data[$eventOutputs]], Catenate[data[$eventInputs]]] -> {}}

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "AllEventsList"] :=
  If[MatchQ[boundary, "Final" | None], Rest, Identity] @
    If[MatchQ[boundary, "Final" | All], Append[finalEvent[obj]], Identity] @
      Transpose[{data[$eventRuleIDs], Thread[data[$eventInputs] -> data[$eventOutputs]]}]

(* EventsStatesList *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
      obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
      caller_,
      "EventsStatesList"] := With[{
    events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"],
    states = If[MatchQ[boundary, None | "Final"], Rest, # &] @
      If[MatchQ[boundary, All | "Final"], Append[{}], # &] @
      propertyEvaluate[True, boundary][obj, caller, "AllEventsStatesEdgeIndicesList"]},
  Transpose[{events, states}]
]

(* EdgeCreatorEventIndices *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "EdgeCreatorEventIndices"] := ModuleScope[
  events = propertyEvaluate[True, "Initial"][obj, caller, "AllEventsList"];
  eventOutputs = events[[All, 2, 2]];
  Sort[Catenate[Thread /@ Thread[eventOutputs -> Range[Length[events]] - 1]]][[All, 2]]
]

(* EdgeDestroyerEventsIndices *)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "EdgeDestroyerEventsIndices"] := ModuleScope[
  events = propertyEvaluate[True, "Final"][obj, caller, "AllEventsList"];
  eventInputs = events[[All, 2, 1]];
  edgeToDestroyerRules = Sort[Catenate[Thread /@ Thread[eventInputs -> Append[Range[Length[events] - 1], Infinity]]]];
  resultWithInfinities = Map[Last, Values[GroupBy[edgeToDestroyerRules, First]], {2}];
  If[MatchQ[boundary, None | "Initial"], resultWithInfinities /. Infinity -> Nothing, resultWithInfinities]
]

(* EdgeDestroyerEventIndices *)

eventListToSingleEvent[caller_, {event_}, _] := event

eventListToSingleEvent[caller_, {_, __}, expression_] := (
  makeMessage[caller, "multiwayState", expression];
  Throw[$Failed]
)

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
    caller_,
    "EdgeDestroyerEventIndices"] := ModuleScope[
  eventLists = propertyEvaluate[True, "Final"][obj, caller, "EdgeDestroyerEventsIndices"];
  MapIndexed[eventListToSingleEvent[caller, #, #2[[1]]] &, eventLists]
]

(* EdgeGenerationsList *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "EdgeGenerationsList"] := (
  propertyEvaluate[True, "Initial"][obj, caller, "EventGenerations"][[
    propertyEvaluate[True, "Initial"][obj, caller, "EdgeCreatorEventIndices"] + 1]]
)

(* FeatureVector *)

vertexDegreeQuantiles[g_Graph] := Quantile[VertexDegree[g], {0, 0.25, 0.50, 0.75, 1}]
vertexDegreeQuantiles[g_Graph] /; VertexCount[g] == 0 := {0, 0, 0, 0, 0} (* Edge case for empty graphs *)

causalGraphFeatureAssociation[g_Graph] := <|
    "VertexCount" -> VertexCount[g],
    "EdgeCount" -> EdgeCount[g],
    "VertexConnectivity" -> VertexConnectivity[UndirectedGraph[g]],
    "VertexDegreesQuantiles" -> vertexDegreeQuantiles[g]
|>

causalGraphFeatureVector[g_Graph] := Flatten @ Values[causalGraphFeatureAssociation[g]]

propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "FeatureVector"] := causalGraphFeatureVector[propertyEvaluate[True, boundary][obj, caller, "CausalGraph"]]

(* ExpressionsSeparation *)

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "ExpressionsSeparation", signedExpr1_, signedExpr2_] := ModuleScope[
  {expr1, expr2} =
    toPositiveParameter[
        1, propertyEvaluate[True, None][obj, caller, "ExpressionsCountTotal"], #, caller, "Expression"] & /@
      {signedExpr1, signedExpr2};
  expressionsEventsGraph = propertyEvaluate[True, "Initial"][obj, caller, "ExpressionsEventsGraph"];
  If[expr1 === expr2, Return["Identical"]];
  causalCones = VertexInComponent[expressionsEventsGraph, {"Expression", #}] & /@ {expr1, expr2};
  intersection = Intersection @@ causalCones;
  intersectionBoundary =
    intersection[[Position[VertexOutDegree[Subgraph[expressionsEventsGraph, intersection]], 0][[All, 1]]]];
  boundaryExpressions = Cases[intersectionBoundary, {"Expression", expr_} :> expr];
  If[!FreeQ[boundaryExpressions, expr1 | expr2], Return["Timelike"]];
  If[Length[boundaryExpressions] =!= 0, "Branchlike", "Spacelike"]
]

propertyEvaluate[True, includeBoundaryEventsPattern][
    obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
    caller_,
    "MultiwayQ"] := ModuleScope[
  Max[Length /@ propertyEvaluate[True, None][obj, caller, "EdgeDestroyerEventsIndices"]] > 1
]

(* Public properties call *)

$masterOptions = {
  "IncludePartialGenerations" -> True,
  "IncludeBoundaryEvents" -> None
};

WolframModelEvolutionObject[
    data_ ? evolutionDataQ][
    property__ ? (Not[MatchQ[#, OptionsPattern[]]] &),
    opts : OptionsPattern[]] := ModuleScope[
  result = Catch[
    (propertyEvaluate @@
        (OptionValue[Join[{opts}, $masterOptions], #] & /@ {"IncludePartialGenerations", "IncludeBoundaryEvents"}))[
      WolframModelEvolutionObject[data],
      WolframModelEvolutionObject,
      property,
      ##] & @@ Flatten[FilterRules[{opts}, Except[$masterOptions]]]];
  result /; result =!= $Failed
]

(** Argument Checks **)
(* Argument Checks should be evaluated after Implementation, otherwise ::corrupt messages will be created while
   assigning SubValues. *)

(* Argument count *)

WolframModelEvolutionObject[args___] := 0 /;
  !Developer`CheckArgumentCount[WolframModelEvolutionObject[args], 1, 1] && False

WolframModelEvolutionObject[data_][opts : OptionsPattern[]] := 0 /;
  Message[WolframModelEvolutionObject::argm, Defer[WolframModelEvolutionObject[data][opts]], 0, 1]

(* Association has correct fields *)

$currentVersion = 2;

evolutionDataQ[data_Association] := evolutionDataQ[Lookup[data, $version, 1], data]

evolutionDataQ[1, data_Association] :=
  Sort[Keys[data]] === Sort[{
    $creatorEvents, $destroyerEvents, $generations, $atomLists, $rules, $maxCompleteGeneration, $terminationReason,
    $eventRuleIDs}]

evolutionDataQ[2, data_Association] :=
  Keys[data] === {
    $version, $rules, $maxCompleteGeneration, $terminationReason, $atomLists, $eventRuleIDs, $eventInputs,
    $eventOutputs, $eventGenerations}

evolutionDataQ[___] := False

WolframModelEvolutionObject::migrationInputOrdering =
  "Migrating the evolution object from version 1. The ordering of event inputs may be incorrect.";

migrateEvolutionObjectData[data_, 1, 2] := ModuleScope[
  Message[WolframModelEvolutionObject::migrationInputOrdering];
  {eventsToInputs, eventsToOutputs} =
    GroupBy[Thread[data[#] -> Range[Length[data[#]]]], First][[All, All, 2]] & /@ {$destroyerEvents, $creatorEvents};
  {eventInputs, eventOutputs} = Function[{eventsToExpressions},
    Lookup[eventsToExpressions, #, {}] & /@ Range[0, Length[data[$eventRuleIDs]]]] /@ {eventsToInputs, eventsToOutputs};
  <|$version -> 2,
    $rules -> data[$rules],
    $maxCompleteGeneration -> data[$maxCompleteGeneration],
    $terminationReason -> data[$terminationReason],
    $atomLists -> data[$atomLists],
    $eventRuleIDs -> Join[{0}, data[$eventRuleIDs]],
    $eventInputs -> eventInputs,
    $eventOutputs -> eventOutputs,
    $eventGenerations -> (Max[Append[#, -1]] + 1 &) /@ Map[data[$generations][[#]] &, eventInputs, {2}]|>
]

WolframModelEvolutionObject[data_] /;
    Lookup[data, $version, 1] < $currentVersion && evolutionDataQ[data] :=
  WolframModelEvolutionObject[migrateEvolutionObjectData[data, Lookup[data, $version, 1], 2]]

WolframModelEvolutionObject::future =
  "WolframModelEvolutionObject is produced by a later version of SetReplace. " <>
  "Evaluate PacletInstall[\"SetReplace\"], or check " <>
  "https://github.com/maxitg/SetReplace/blob/master/README.md#getting-started to install manually.";

WolframModelEvolutionObject[data_] /; data[$version] > $currentVersion := 0 /;
  Message[WolframModelEvolutionObject::future]

WolframModelEvolutionObject::corrupt =
  "WolframModelEvolutionObject does not have a correct format. " <>
  "Use WolframModel for construction.";

WolframModelEvolutionObject[data_] /;
    Lookup[data, $version, 1] <= $currentVersion && !evolutionDataQ[data] := 0 /;
  Message[WolframModelEvolutionObject::corrupt]
